{"ast":null,"code":"var symbols = require('./symbols'),\n  cleanErrorRegex = /((?:\\n.*__kgoRunStep__[^]+|\\n.*__kgoDeferredCallback__)[^]+?\\n[^]+?(?:\\n|$))/;\nfunction cleanError(stack, error) {\n  var currentStack = '';\n  if (error instanceof Error) {\n    currentStack = error.stack ? error.stack.replace(cleanErrorRegex, '') : currentStack;\n  } else {\n    error = new Error(error);\n    error.stack = '';\n  }\n  error.stack = 'Error: ' + error.message + currentStack + stack;\n  return error;\n}\nfunction Step(task, args, done) {\n  this._task = task;\n  this._args = args;\n  this._done = done;\n}\nStep.prototype.run = function __kgoRunStep__() {\n  var step = this;\n  function complete(error) {\n    if (step._complete) {\n      throw cleanError(step._task.stack, 'Step callback called more than once for task: ' + step._task.names);\n    }\n    step._complete = true;\n    var result = Array.prototype.slice.call(arguments, 1);\n    if (error instanceof Error) {\n      error = cleanError(step._task.stack, error);\n    }\n    step.done(error, result);\n  }\n  try {\n    var args = this._args.slice();\n    if (!this._task.returnless) {\n      args.push(complete);\n    }\n    this._task.fn.apply(this, args);\n  } catch (error) {\n    throw cleanError(step._task.stack, error);\n  }\n};\nStep.prototype.done = function (error, result) {\n  if (error) {\n    return this._done(error);\n  }\n  this._done(null, result);\n};\nfunction runTask(task, results, errors, aboutToRun, done) {\n  var names = task.names,\n    dependants = task.args,\n    args = [],\n    error = errors[symbols.errorSymbol],\n    numDeps = 0,\n    metDeps = 0,\n    allDepsMet;\n  if (dependants) {\n    var useError, hasError;\n    for (var i = 0; i < dependants.length; i++) {\n      var dependantName = dependants[i],\n        isErrorDep = dependantName.match(symbols.errorDependency),\n        ignore = dependantName.match(symbols.ignoreDependency);\n      if (isErrorDep) {\n        useError = true;\n        hasError = hasError || dependantName in errors;\n        continue;\n      }\n      if (ignore) {\n        dependantName = dependantName.slice(1);\n      }\n      numDeps++;\n      if (dependantName in results) {\n        metDeps++;\n      }\n    }\n    allDepsMet = numDeps === metDeps;\n    if (!allDepsMet && !hasError || !numDeps && useError && !hasError || !hasError && error) {\n      return;\n    }\n    for (var i = 0; i < dependants.length; i++) {\n      var dependantName = dependants[i],\n        isErrorDep = dependantName.match(symbols.errorDependency),\n        ignore = dependantName.match(symbols.ignoreDependency);\n      if (isErrorDep) {\n        args.push(errors[dependantName]);\n        continue;\n      }\n      if (ignore) {\n        continue;\n      }\n      if (hasError) {\n        args.push(undefined);\n        continue;\n      }\n      args.push(results[dependantName]);\n    }\n  }\n  var step = new Step(task, args, function (error, results) {\n    done(names, error, results);\n  });\n  aboutToRun(names);\n  step.run();\n}\nfunction run(tasks, results, errors, kgo) {\n  var currentTask,\n    noMoreTasks = true;\n  for (var key in tasks) {\n    noMoreTasks = false;\n    currentTask = tasks[key];\n    runTask(currentTask, results, errors, function (names) {\n      names.map(function (name) {\n        delete tasks[name];\n      });\n    }, function (names, taskError, taskResults) {\n      if (taskError && !errors[symbols.errorSymbol]) {\n        errors[symbols.errorSymbol] = taskError;\n      }\n      for (var i = 0; i < names.length; i++) {\n        if (taskError) {\n          errors[symbols.errorSymbol + names[i]] = taskError;\n        } else {\n          results[names[i]] = taskResults[i];\n        }\n      }\n      run(tasks, results, errors, kgo);\n    });\n  }\n}\nfunction cloneAndRun(tasks, results, kgo) {\n  var todo = {},\n    errors = {};\n  kgo._taskCount = Object.keys(results).length;\n  function checkDependencyIsDefined(dependencyName) {\n    var taskName = dependencyName.match(/[!*]?(.*)/)[1];\n    if (dependencyName !== symbols.errorSymbol && !(taskName in tasks) && !(taskName in results)) {\n      throw cleanError(this.stack, 'No task or result has been defined for dependency: ' + taskName);\n    }\n  }\n  for (var key in tasks) {\n    todo[key] = tasks[key];\n    kgo._taskCount++;\n    tasks[key].args.map(checkDependencyIsDefined, tasks[key]);\n  }\n  run(todo, results, errors, kgo);\n}\nmodule.exports = cloneAndRun;","map":{"version":3,"names":["symbols","require","cleanErrorRegex","cleanError","stack","error","currentStack","Error","replace","message","Step","task","args","done","_task","_args","_done","prototype","run","__kgoRunStep__","step","complete","_complete","names","result","Array","slice","call","arguments","returnless","push","fn","apply","runTask","results","errors","aboutToRun","dependants","errorSymbol","numDeps","metDeps","allDepsMet","useError","hasError","i","length","dependantName","isErrorDep","match","errorDependency","ignore","ignoreDependency","undefined","tasks","kgo","currentTask","noMoreTasks","key","map","name","taskError","taskResults","cloneAndRun","todo","_taskCount","Object","keys","checkDependencyIsDefined","dependencyName","taskName","module","exports"],"sources":["E:/MERN/AI image Generation App/ai_image_generation_app/client/node_modules/kgo/run.js"],"sourcesContent":["var symbols = require('./symbols'),\n    cleanErrorRegex = /((?:\\n.*__kgoRunStep__[^]+|\\n.*__kgoDeferredCallback__)[^]+?\\n[^]+?(?:\\n|$))/;\n\nfunction cleanError(stack, error){\n    var currentStack = '';\n    if(error instanceof Error){\n        currentStack = error.stack ? error.stack.replace(cleanErrorRegex, '') : currentStack;\n    }else{\n        error = new Error(error);\n        error.stack = '';\n    }\n    error.stack = 'Error: ' + error.message + currentStack + stack;\n    return error;\n}\n\nfunction Step(task, args, done){\n    this._task = task;\n    this._args = args;\n    this._done = done;\n}\nStep.prototype.run = function __kgoRunStep__(){\n    var step = this;\n\n    function complete(error){\n\n        if(step._complete){\n            throw cleanError(step._task.stack, 'Step callback called more than once for task: ' + step._task.names);\n        }\n\n        step._complete = true;\n\n        var result = Array.prototype.slice.call(arguments, 1);\n\n        if(error instanceof Error){\n            error = cleanError(step._task.stack, error);\n        }\n\n        step.done(error, result);\n    }\n\n    try{\n        var args = this._args.slice();\n        if(!this._task.returnless){\n            args.push(complete);\n        }\n        this._task.fn.apply(this, args);\n    }catch(error){\n        throw cleanError(step._task.stack, error);\n    }\n};\nStep.prototype.done = function(error, result){\n\n    if(error){\n        return this._done(error);\n    }\n    this._done(null, result);\n};\n\nfunction runTask(task, results, errors, aboutToRun, done){\n    var names = task.names,\n        dependants = task.args,\n        args = [],\n        error = errors[symbols.errorSymbol],\n        numDeps = 0,\n        metDeps = 0,\n        allDepsMet;\n\n    if(dependants){\n        var useError,\n            hasError;\n\n        for(var i = 0; i < dependants.length; i++) {\n            var dependantName = dependants[i],\n                isErrorDep = dependantName.match(symbols.errorDependency),\n                ignore = dependantName.match(symbols.ignoreDependency);\n\n            if(isErrorDep){\n                useError = true;\n                hasError = hasError || dependantName in errors;\n                continue;\n            }\n\n            if(ignore){\n                dependantName = dependantName.slice(1);\n            }\n\n            numDeps++;\n\n            if(dependantName in results){\n                metDeps++;\n            }\n        }\n\n        allDepsMet = numDeps === metDeps;\n\n        if(!allDepsMet && !hasError || !numDeps && useError && !hasError || !hasError && error){\n            return;\n        }\n\n        for(var i = 0; i < dependants.length; i++) {\n            var dependantName = dependants[i],\n                isErrorDep = dependantName.match(symbols.errorDependency),\n                ignore = dependantName.match(symbols.ignoreDependency);\n\n            if(isErrorDep){\n                args.push(errors[dependantName]);\n                continue;\n            }\n\n            if(ignore){\n                continue;\n            }\n\n            if(hasError){\n                args.push(undefined);\n                continue;\n            }\n\n            args.push(results[dependantName]);\n        }\n    }\n\n    var step = new Step(task, args, function(error, results){\n        done(names, error, results);\n    });\n\n    aboutToRun(names);\n    step.run();\n}\n\nfunction run(tasks, results, errors, kgo){\n    var currentTask,\n        noMoreTasks = true;\n\n    for(var key in tasks){\n        noMoreTasks = false;\n        currentTask = tasks[key];\n\n        runTask(\n            currentTask,\n            results,\n            errors,\n            function(names){\n                names.map(function(name){\n                    delete tasks[name];\n                });\n            },\n            function(names, taskError, taskResults){\n                if(taskError && !errors[symbols.errorSymbol]){\n                    errors[symbols.errorSymbol] = taskError;\n                }\n\n                for(var i = 0; i < names.length; i++){\n                    if(taskError){\n                        errors[symbols.errorSymbol + names[i]] = taskError;\n                    }else{\n                        results[names[i]] = taskResults[i];\n                    }\n                }\n\n                run(tasks, results, errors, kgo);\n            }\n        );\n    }\n}\n\nfunction cloneAndRun(tasks, results, kgo){\n    var todo = {},\n        errors = {};\n\n    kgo._taskCount = Object.keys(results).length;\n\n    function checkDependencyIsDefined(dependencyName){\n        var taskName = dependencyName.match(/[!*]?(.*)/)[1];\n\n        if(dependencyName !== symbols.errorSymbol && !(taskName in tasks) && !(taskName in results)){\n            throw cleanError(this.stack, 'No task or result has been defined for dependency: ' + taskName);\n        }\n    }\n\n    for(var key in tasks){\n        todo[key] = tasks[key];\n        kgo._taskCount ++;\n\n        tasks[key].args.map(checkDependencyIsDefined, tasks[key]);\n    }\n\n    run(todo, results, errors, kgo);\n}\n\nmodule.exports = cloneAndRun;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}