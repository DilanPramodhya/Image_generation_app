{"ast":null,"code":"const fs = require('graceful-fs');\nconst path = require('path');\nconst hashr = require('hashr');\nconst kgo = require('kgo');\nconst StreamCatcher = require('stream-catcher');\nconst chokidar = require('chokidar');\nconst watchers = {};\nconst cacheMaxSize = 1024 * 1000;\nfunction cacheLengthFunction(n) {\n  return n.length;\n}\nfunction createReadStream(fileServer, request, response) {\n  return function (key) {\n    const readStream = fs.createReadStream(key);\n    readStream.on('error', fileServer.errorCallback.bind(null, request, response));\n    fileServer.cache.read(key, readStream);\n  };\n}\nfunction FileServer(errorCallback, cacheSize) {\n  if (!errorCallback) {\n    throw new Error('Must supply an error callback to File Server');\n  }\n  this.cache = new StreamCatcher({\n    length: cacheLengthFunction,\n    max: cacheSize == null ? cacheMaxSize : cacheSize\n  });\n  this.errorCallback = function (request, response, error) {\n    errorCallback(error, request, response);\n  };\n\n  // Local watchers for programmatic closing\n  this.watchers = {};\n}\nFileServer.prototype.getFile = function (stats, fileName, mimeType, maxAge, request, response) {\n  const fileServer = this;\n  if (!stats.isFile()) {\n    return fileServer.errorCallback(request, response, {\n      code: 404,\n      message: `404: Not Found ${fileName}`\n    });\n  }\n  const eTag = hashr.hash(fileName + stats.mtime.getTime());\n  response.setHeader('ETag', eTag);\n  response.setHeader('Cache-Control', `private, max-age=${maxAge}`);\n  if (request.headers && request.headers['if-none-match'] === eTag) {\n    response.writeHead(304);\n    return response.end();\n  }\n  response.setHeader('Content-Type', mimeType);\n  response.on('error', fileServer.errorCallback.bind(null, request, response));\n  if (stats.size === 0) {\n    return response.end();\n  }\n  fileServer.cache.write(fileName, response, createReadStream(fileServer, request, response));\n};\nfunction getStats(acceptsGzip, fileName, response, done) {\n  const gzipFileName = `${fileName}.gz`;\n  if (acceptsGzip) {\n    fs.stat(gzipFileName, (error, stats) => {\n      if (error) {\n        return fs.stat(fileName, (error, stats) => {\n          done.call(null, error, stats, fileName);\n        });\n      }\n      response.setHeader('Content-Encoding', 'gzip');\n      done(null, stats, gzipFileName);\n    });\n    return;\n  }\n  fs.stat(fileName, (error, stats) => {\n    done.call(null, error, stats, fileName);\n  });\n}\nFileServer.prototype.serveFile = function (fileName, mimeType = 'text/plain', maxAge = 0) {\n  const fileServer = this;\n  if (!watchers[fileName]) {\n    const watcher = chokidar.watch(fileName, {\n      persistent: true,\n      ignoreInitial: true\n    });\n    watcher.on('change', () => {\n      fileServer.cache.del(fileName);\n    });\n    watchers[fileName] = watcher;\n    // Add to local instance for programmtic closing\n    this.watchers[fileName] = watcher;\n  }\n  if (!fileName || typeof fileName !== 'string') {\n    throw new Error('Must provide a fileName to serveFile');\n  }\n  return function (request, response) {\n    const acceptsGzip = request.headers && request.headers['accept-encoding'] && ~request.headers['accept-encoding'].indexOf('gzip');\n    kgo({\n      acceptsGzip,\n      fileName,\n      mimeType,\n      maxAge,\n      request,\n      response\n    })('stats', 'finalFilename', ['acceptsGzip', 'fileName', 'response'], getStats)(['stats', 'finalFilename', 'mimeType', 'maxAge', 'request', 'response'], fileServer.getFile.bind(fileServer))(['*'], error => {\n      if (error.message && ~error.message.indexOf('ENOENT')) {\n        return fileServer.errorCallback(request, response, {\n          code: 404,\n          message: `404: Not Found ${fileName}`\n        });\n      }\n      return fileServer.errorCallback(request, response, error);\n    });\n  };\n};\nFileServer.prototype.serveDirectory = function (rootDirectory, mimeTypes, maxAge = 0) {\n  const fileServer = this;\n  if (!rootDirectory || typeof rootDirectory !== 'string') {\n    throw new Error('Must provide a rootDirectory to serveDirectory');\n  }\n  if (!mimeTypes || typeof mimeTypes !== 'object') {\n    throw new Error('Must provide a mimeTypes object to serveDirectory');\n  }\n  const keys = Object.keys(mimeTypes);\n  for (let i = 0; i < keys.length; i++) {\n    if (keys[i].charAt(0) !== '.') {\n      throw new Error(`Extension found without a leading periond (\".\"): ${keys[i]}`);\n    }\n  }\n  return function (request, response, fileName) {\n    if (arguments.length < 3) {\n      fileName = request.url.slice(1);\n    }\n    const filePath = path.join(rootDirectory, fileName);\n    const extention = path.extname(filePath).toLowerCase();\n    if (!mimeTypes[extention]) {\n      return fileServer.errorCallback(request, response, {\n        code: 404,\n        message: `404: Not Found ${filePath}`\n      });\n    }\n    if (~path.relative(rootDirectory, filePath).indexOf('..')) {\n      return fileServer.errorCallback(request, response, {\n        code: 404,\n        message: `404: Not Found ${fileName}`\n      });\n    }\n    fileServer.serveFile(filePath, mimeTypes[extention], maxAge)(request, response);\n  };\n};\nFileServer.prototype.close = function (onClose) {\n  const closePromises = [];\n  Object.keys(this.watchers).forEach(key => {\n    const watcher = this.watchers[key];\n    closePromises.push(watcher.close());\n    delete this.watchers[key];\n  });\n  Promise.all(closePromises).then(() => {\n    onClose();\n  });\n};\nprocess.on('exit', () => {\n  Object.values(watchers).forEach(watcher => watcher.close());\n});\nmodule.exports = FileServer;","map":{"version":3,"names":["fs","require","path","hashr","kgo","StreamCatcher","chokidar","watchers","cacheMaxSize","cacheLengthFunction","n","length","createReadStream","fileServer","request","response","key","readStream","on","errorCallback","bind","cache","read","FileServer","cacheSize","Error","max","error","prototype","getFile","stats","fileName","mimeType","maxAge","isFile","code","message","eTag","hash","mtime","getTime","setHeader","headers","writeHead","end","size","write","getStats","acceptsGzip","done","gzipFileName","stat","call","serveFile","watcher","watch","persistent","ignoreInitial","del","indexOf","serveDirectory","rootDirectory","mimeTypes","keys","Object","i","charAt","arguments","url","slice","filePath","join","extention","extname","toLowerCase","relative","close","onClose","closePromises","forEach","push","Promise","all","then","process","values","module","exports"],"sources":["E:/MERN/AI image Generation App/ai_image_generation_app/client/node_modules/file-server/index.js"],"sourcesContent":["const fs = require('graceful-fs');\nconst path = require('path');\nconst hashr = require('hashr');\nconst kgo = require('kgo');\nconst StreamCatcher = require('stream-catcher');\nconst chokidar = require('chokidar');\n\nconst watchers = {};\nconst cacheMaxSize = 1024 * 1000;\n\nfunction cacheLengthFunction(n) {\n    return n.length;\n}\n\nfunction createReadStream(fileServer, request, response) {\n    return function(key) {\n        const readStream = fs.createReadStream(key);\n\n        readStream.on('error', fileServer.errorCallback.bind(null, request, response));\n\n        fileServer.cache.read(key, readStream);\n    };\n}\n\nfunction FileServer(errorCallback, cacheSize) {\n    if (!errorCallback) {\n        throw new Error('Must supply an error callback to File Server');\n    }\n\n    this.cache = new StreamCatcher({\n        length: cacheLengthFunction,\n        max: cacheSize == null ? cacheMaxSize : cacheSize,\n    });\n\n    this.errorCallback = function(request, response, error) {\n        errorCallback(error, request, response);\n    };\n\n    // Local watchers for programmatic closing\n    this.watchers = {};\n}\n\nFileServer.prototype.getFile = function(stats, fileName, mimeType, maxAge, request, response) {\n    const fileServer = this;\n\n    if (!stats.isFile()) {\n        return fileServer.errorCallback(request, response, { code: 404, message: `404: Not Found ${fileName}` });\n    }\n\n    const eTag = hashr.hash(fileName + stats.mtime.getTime());\n\n    response.setHeader('ETag', eTag);\n    response.setHeader('Cache-Control', `private, max-age=${maxAge}`);\n\n    if (request.headers && request.headers['if-none-match'] === eTag) {\n        response.writeHead(304);\n        return response.end();\n    }\n\n    response.setHeader('Content-Type', mimeType);\n\n    response.on('error', fileServer.errorCallback.bind(null, request, response));\n\n    if (stats.size === 0) {\n        return response.end();\n    }\n\n    fileServer.cache.write(fileName, response, createReadStream(fileServer, request, response));\n};\n\nfunction getStats(acceptsGzip, fileName, response, done) {\n    const gzipFileName = `${fileName}.gz`;\n\n    if (acceptsGzip) {\n        fs.stat(gzipFileName, (error, stats) => {\n            if (error) {\n                return fs.stat(fileName, (error, stats) => {\n                    done.call(null, error, stats, fileName);\n                });\n            }\n\n            response.setHeader('Content-Encoding', 'gzip');\n            done(null, stats, gzipFileName);\n        });\n        return;\n    }\n\n    fs.stat(fileName, (error, stats) => {\n        done.call(null, error, stats, fileName);\n    });\n}\n\nFileServer.prototype.serveFile = function(fileName, mimeType = 'text/plain', maxAge = 0) {\n    const fileServer = this;\n\n    if (!watchers[fileName]) {\n        const watcher = chokidar.watch(fileName, { persistent: true, ignoreInitial: true });\n        watcher.on('change', () => {\n            fileServer.cache.del(fileName);\n        });\n        watchers[fileName] = watcher;\n        // Add to local instance for programmtic closing\n        this.watchers[fileName] = watcher;\n    }\n\n    if (!fileName || typeof fileName !== 'string') {\n        throw new Error('Must provide a fileName to serveFile');\n    }\n\n    return function(request, response) {\n        const acceptsGzip =\n            request.headers &&\n            request.headers['accept-encoding'] &&\n            ~request.headers['accept-encoding'].indexOf('gzip');\n\n        kgo({\n            acceptsGzip,\n            fileName,\n            mimeType,\n            maxAge,\n            request,\n            response,\n        })\n        ('stats', 'finalFilename', ['acceptsGzip', 'fileName', 'response'], getStats)\n        (['stats', 'finalFilename', 'mimeType', 'maxAge', 'request', 'response'], fileServer.getFile.bind(fileServer))\n        (['*'], error => {\n            if (error.message && ~error.message.indexOf('ENOENT')) {\n                return fileServer.errorCallback(request, response, {\n                    code: 404,\n                    message: `404: Not Found ${fileName}`,\n                });\n            }\n\n            return fileServer.errorCallback(request, response, error);\n        });\n    };\n};\n\nFileServer.prototype.serveDirectory = function(rootDirectory, mimeTypes, maxAge = 0) {\n    const fileServer = this;\n\n    if (!rootDirectory || typeof rootDirectory !== 'string') {\n        throw new Error('Must provide a rootDirectory to serveDirectory');\n    }\n\n    if (!mimeTypes || typeof mimeTypes !== 'object') {\n        throw new Error('Must provide a mimeTypes object to serveDirectory');\n    }\n\n    const keys = Object.keys(mimeTypes);\n\n    for (let i = 0; i < keys.length; i++) {\n        if (keys[i].charAt(0) !== '.') {\n            throw new Error(`Extension found without a leading periond (\".\"): ${keys[i]}`);\n        }\n    }\n\n    return function(request, response, fileName) {\n        if (arguments.length < 3) {\n            fileName = request.url.slice(1);\n        } \n\n        const filePath = path.join(rootDirectory, fileName);\n\n        const extention = path.extname(filePath).toLowerCase();\n\n        if (!mimeTypes[extention]) {\n            return fileServer.errorCallback(request, response, { code: 404, message: `404: Not Found ${filePath}` });\n        }\n\n        if (~path.relative(rootDirectory, filePath).indexOf('..')) {\n            return fileServer.errorCallback(request, response, { code: 404, message: `404: Not Found ${fileName}` });\n        }\n\n        fileServer.serveFile(filePath, mimeTypes[extention], maxAge)(request, response);\n    };\n};\n\nFileServer.prototype.close = function(onClose) {\n    const closePromises = [];\n    Object.keys(this.watchers).forEach((key) => {\n        const watcher = this.watchers[key];\n        closePromises.push(watcher.close());\n        delete this.watchers[key];\n    });\n    \n    Promise.all(closePromises).then(() => {\n        onClose();\n    });\n}\n\nprocess.on('exit', () => {\n    Object.values(watchers).forEach(watcher => watcher.close());\n});\n\nmodule.exports = FileServer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}